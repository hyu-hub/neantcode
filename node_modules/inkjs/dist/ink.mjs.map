{"version":3,"file":"ink.mjs","sources":["../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/Value.ts","../src/engine/PushPop.ts","../src/engine/Error.ts","../src/engine/TypeAssertion.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/Glue.ts","../src/engine/ControlCommand.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/ChoicePoint.ts","../src/engine/VariableReference.ts","../src/engine/VariableAssignment.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinition.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts"],"sourcesContent":["export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string },\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    if (myListItem == null || myListItem == \"\") return new InkList();\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(\n    itemOrItemName: InkListItem | string | null,\n    storyObject: Story | null = null\n  ) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else if (itemOrItemName !== null) {\n      //itemOrItemName is a string\n      let itemName = itemOrItemName as string;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null) {\n        if (storyObject == null) {\n          throw new Error(\n            \"Could not add the item \" +\n              itemName +\n              \" to this list because it isn't known to any list definitions previously associated with this list.\"\n          );\n        } else {\n          let newItem = InkList.FromString(itemName, storyObject)\n            .orderedItems[0];\n          this.Add(newItem.Key, newItem.Value);\n        }\n      } else {\n        let item = new InkListItem(foundListDef.name, itemName);\n        let itemVal = foundListDef.ValueForItem(item);\n        this.Add(item, itemVal);\n      }\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (maxBound instanceof InkList && maxBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n\n  get singleItem(): InkListItem | null {\n    for (let item of this.orderedItems) {\n      return item.Key;\n    }\n    return null;\n  }\n\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      // Couldn't resolve entire path?\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      // Are we about to loop into another container?\n      // Is the object a container as expected? It might\n      // no longer be if the content has shuffled around, so what\n      // was originally a container no longer is.\n      const nextContainer: Container | null = asOrNull(foundObj, Container);\n      if (i < partialPathLength - 1 && nextContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = nextContainer;\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Start = 0,\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return \"ControlCommand \" + this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {\n  public toString() {\n    return \"Void\";\n  }\n}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          \"Attempting to perform \" +\n            this.name +\n            ' on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T extends { toString: () => string }>(\n    parametersOfSingleType: Array<Value<T>>\n  ) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n\n  public Clone() {\n    let copy = new Choice();\n    copy.text = this.text;\n    copy.sourcePath = this.sourcePath;\n    copy.index = this.index;\n    copy.targetPath = this.targetPath;\n    copy.originalThreadIndex = this.originalThreadIndex;\n    copy.isInvisibleDefault = this.isInvisibleDefault;\n    if (this.threadAtGeneration !== null)\n      copy.threadAtGeneration = this.threadAtGeneration.Copy();\n\n    return copy;\n  }\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n\n  public TryGetValueForItem(\n    item: InkListItem,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    choice.tags = this.JArrayToTags(jObj);\n    return choice;\n  }\n\n  public static JArrayToTags(jObj: Record<string, any>) {\n    if (jObj[\"tags\"]) {\n      return jObj[\"tags\"];\n    } else {\n      return null;\n    }\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    this.WriteChoiceTags(writer, choice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteChoiceTags(writer: SimpleJson.Writer, choice: Choice) {\n    if (choice.tags && choice.tags.length > 0) {\n      writer.WritePropertyStart(\"tags\");\n      writer.WriteArrayStart();\n      for (const tag of choice.tags!) {\n        writer.Write(tag);\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    // contextIndex 0 means global, so index is actually 1-based\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container !== null) {\n                storyContext.Warning(\n                  \"When loading state, exact internal story location couldn't be found: '\" +\n                    currentContainerPathStr +\n                    \"', so it was approximated to '\" +\n                    pointer.container.path.toString() +\n                    \"' to recover. Has the story changed since this save data was created?\"\n                );\n              } else {\n                storyContext.Warning(\n                  \"When loading state, exact internal story location couldn't be found: '\" +\n                    currentContainerPathStr +\n                    \"' and it may not be recoverable. Has the story changed since this save data was created?\"\n                );\n              }\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  public StartVariableObservation() {\n    this._batchObservingVariableChanges = true;\n    this._changedVariablesForBatchObs = new Set();\n  }\n\n  public CompleteVariableObservation(): Map<string, any> {\n    this._batchObservingVariableChanges = false;\n    let changedVars = new Map<string, any>();\n    if (this._changedVariablesForBatchObs != null) {\n      for (let variableName of this._changedVariablesForBatchObs) {\n        let currentValue = this._globalVariables.get(variableName) as InkObject;\n        this.variableChangedEvent(variableName, currentValue);\n      }\n    }\n    // Patch may still be active - e.g. if we were in the middle of a background save\n    if (this.patch != null) {\n      for (let variableName of this.patch.changedVariables) {\n        let patchedVal = this.patch.TryGetGlobal(variableName, null);\n        if (patchedVal.exists) changedVars.set(variableName, patchedVal);\n      }\n    }\n    this._changedVariablesForBatchObs = null;\n    return changedVars;\n  }\n\n  public NotifyObservers(changedVars: Map<string, any>) {\n    for (const [key, value] of changedVars) {\n      this.variableChangedEvent(key, value);\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this._batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n\n  private _batchObservingVariableChanges: boolean = false;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection(): Record<string, any> | null {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get previousPathString() {\n    let pointer = this.previousPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"previousPointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching(forBackgroundSave: boolean) {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    // When background saving we need to make copies of choices since they each have\n    // a snapshot of the thread at the time of generation since the game could progress\n    // significantly and threads modified during the save process.\n    // However, when doing internal saving and restoring of snapshots this isn't an issue,\n    // and we can simply ref-copy the choices with their existing threads.\n\n    if (forBackgroundSave) {\n      for (let choice of this._currentFlow.currentChoices) {\n        copy._currentFlow.currentChoices.push(choice.Clone());\n      }\n    } else {\n      copy._currentFlow.currentChoices.push(\n        ...this._currentFlow.currentChoices\n      );\n    }\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(innerStrStart, innerStrEnd);\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(\n            tailLastNewlineIdx + 1,\n            tailLastNewlineIdx + 1 + numSpaces\n          )\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n              \"number, string, bool or InkList. Argument was \" +\n              (nullIfUndefined(args[i]) === null\n                ? \"null\"\n                : args[i].constructor.name)\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.StartVariableObservation();\n    } else if (this._asyncContinueActive && !isAsyncTimeLimited) {\n      this._asyncContinueActive = false;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    let changedVariablesToObserve: Map<string, any> | null = null;\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        changedVariablesToObserve =\n          this._state.variablesState.CompleteVariableObservation();\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n    if (\n      changedVariablesToObserve != null &&\n      Object.keys(changedVariablesToObserve).length > 0\n    ) {\n      this._state.variablesState.NotifyObservers(changedVariablesToObserve);\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching(false);\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching(true);\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag.reverse()) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || maxInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._state.inStringEvaluation\n    ) {\n      this.Error(\n        \"External function \" +\n          funcName +\n          ' could not be called because 1) it wasn\\'t marked as lookaheadSafe when BindExternalFunction was called and 2) the story is in the middle of string generation, either because choice text is being generated, or because you have ink like \"hello {func()}\". You can work around this by generating the result of your function into a temporary variable before the string or choice gets generated: ~ temp x = ' +\n          funcName +\n          \"()\"\n      );\n    }\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n"],"names":["Path","constructor","this","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","push","concat","Array","relative","isRelative","componentCount","length","tailComps","slice","self","lastComponent","lastComponentIdx","containsNamedComponent","i","l","isIndex","path","GetComponent","index","PathByAppendingPath","pathToAppend","p","upwardMoves","isParent","join","value","substring","componentStrings","split","str","test","parseInt","toString","Equals","otherPath","PathByAppendingComponent","c","Debug","ValueType","PushPopType","ErrorType","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","parentId","indexOrName","static","otherComp","Assert","condition","message","console","warn","trace","AssertType","variable","NullException","throwNullException","InkObject","parent","_debugMetadata","_path","debugMetadata","ownDebugMetadata","DebugLineNumberOfPath","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","comps","child","container","Container","namedChild","unshift","content","indexOf","ResolvePath","nearestContainer","contentContainer","ConvertPathToRelative","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","newPathComps","up","ToParent","down","CompactPathString","globalPathStr","relativePathStr","ancestor","Copy","SetChild","prop","StringBuilder","string","Length","Append","AppendLine","AppendFormat","format","_len","args","_key","replace","match","num","Clear","InkListItem","originName","itemName","nameParts","Null","isNull","fullName","otherItem","copy","serialized","JSON","stringify","key","parse","isLikeInkListItem","inkListItem","item","hasOwnProperty","InkList","Map","super","origins","_originNames","otherList","otherOriginNames","originNames","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","result","singleElement","Add","Key","Value","myListItem","listValue","_a","FindSingleItemListWithName","AddItem","itemOrItemName","storyObject","undefined","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","newItem","FromString","orderedItems","itemVal","ValueForItem","ContainsItemNamed","fromSerializedKey","ContainsKey","has","serializedKey","set","Remove","delete","Count","size","originOfMaxItem","maxOriginName","maxItem","every","initialOriginName","SetInitialOriginNames","initialOriginNames","max","minItem","inverse","list","items","all","Union","union","Intersect","intersection","HasIntersection","Without","listToRemove","Contains","what","GreaterThan","GreaterThanOrEquals","LessThan","LessThanOrEquals","MaxAsList","MinAsList","ListWithSubRange","minBound","maxBound","ordered","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","otherInkList","sort","x","y","localeCompare","singleItem","sb","valueOf","NaN","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","AbstractValue","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","Boolean","StringValue","String","DivertTargetValue","ListValue","Create","valueObject","BadCastException","targetType","valueType","isTruthy","Bool","Cast","newType","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","isNonWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","DivertTarget","targetPath","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","List","listOrSingleItem","singleValue","oldValue","newValue","oldList","newList","SearchResult","approximate","correctObj","searchResult","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","AddContent","namedOnlyContent","namedOnlyContentDict","inkObject","named","existingNamedOnly","AddToNamedContentOnly","countFlags","flags","CountFlags","Visits","Turns","CountStartOnly","flag","pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentList","contentObj","TryAddNamedContent","namedContentObj","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","nextContainer","InsertContent","splice","AddContentsOfContainer","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","onlyNamed","Glue","ControlCommand","commandType","_commandType","CommandType","NotSet","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","Pointer","Resolve","Divert","_targetPath","targetObj","targetPointer","_targetPointer","StartOf","targetPathString","hasVariableTarget","variableDivertName","stackPushType","pushesToStack","isExternal","externalArgs","isConditional","otherDivert","targetStr","Function","ChoicePoint","onceOnly","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","pathOnChoice","choiceTargetObj","choiceTarget","pathStringOnChoice","VariableReference","containerForCount","pathForCount","pathStringForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","functionName","GenerateNativeFunctionsIfNecessary","_nativeFunctions","_name","_isPrototype","_prototype","numberOfParameters","_numberOfParameters","Call","parameters","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","_operationFuncs","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","inkObjectVal","castedValue","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Identity","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","AddListUnaryOp","Invert","All","ListMin","ListMax","ValueOfList","divertTargetsEqual","d1","d2","divertTargetsNotEqual","AddOpToNativeFunc","AddOpFuncForType","nativeFunc","Tag","tagText","text","Choice","threadAtGeneration","sourcePath","tags","originalThreadIndex","Clone","ListDefinition","_items","_itemNameToValues","ContainsItem","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","jArray","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteArrayStart","WriteArrayEnd","dict","WriteIntProperty","WriteRuntimeContainer","divert","divTypeKey","Tunnel","WriteProperty","choicePoint","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","varRef","readCountPath","varAss","tag","choice","WriteChoice","jObject","token","firstChar","CallExistsWithName","CallWithName","isArray","propValue","varPtr","isDivert","divPushType","external","target","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","hasNameProperty","hasTerminator","namedContainer","WriteNull","JArrayToRuntimeObjList","terminatingObj","namedContentItem","namedSubContainer","jObj","JArrayToTags","WriteChoiceTags","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","listDefJson","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","elements","callStack","depth","currentElement","cs","_threads","callstack","currentElementIndex","currentThread","canPop","_threadCounter","_startOfRoot","Story","storyContext","Reset","toCopy","otherThread","Thread","Element","SetJsonToken","jThreads","jThreadTok","jThreadObj","thread","WriteJson","w","WriteObject","PushThread","newThread","threadIndex","ForkThread","forkedThread","PopThread","canPopThread","elementIsEvaluateFromGame","FunctionEvaluationFromGame","Push","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","CanPop","Pop","pop","GetTemporaryVariableWithName","varValue","temporaryVariables","SetTemporaryVariable","declareNew","contextElement","RetainListOriginsForAssignment","ContextForVariableNamed","ThreadWithIndex","filtered","filter","callStackTrace","isCurrent","pointer","inExpressionEvaluation","previousPointer","jThreadCallstack","jElTok","currentContainerPathStr","jElementObj","pushPopType","currentContainerPathStrToken","threadPointerResult","Warning","el","temps","JObjectToDictionaryRuntimeObjs","clear","prevContentObjPath","prevPath","PointerAtPath","e","WriteDictionaryRuntimeObjs","resolvedPointer","VariablesState","variableChangedEvent","callback","variableChangedEventCallbacks","StartVariableObservation","_batchObservingVariableChanges","_changedVariablesForBatchObs","Set","CompleteVariableObservation","changedVars","currentValue","_globalVariables","patch","changedVariables","patchedVal","TryGetGlobal","NotifyObservers","_callStack","$","varContents","_defaultGlobalVariables","SetGlobal","listDefsOrigin","_listDefsOrigin","Proxy","ApplyPatch","namedVarKey","namedVarValue","globals","add","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","GetVariableWithName","GetRawVariableWithName","varPointer","ValueAtVariablePointer","TryGetDefaultVariableValue","GlobalVariableExistsWithName","variableValue","Assign","setGlobal","ResolveVariablePointer","existingPointer","SnapshotDefaultGlobals","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","ObserveVariableChange","PRNG","seed","next","nextFloat","StatePatch","_globals","_changedVariables","visitCounts","_visitCounts","turnIndices","_turnIndices","TryGetVisitCount","SetVisitCount","SetTurnIndex","TryGetTurnIndex","SimpleJson","Reader","ToDictionary","ToArray","_rootObject","Writer","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","inner","StartNewObject","newObject","state","State","Property","currentCollection","currentPropertyName","propertyName","None","StateElement","Object","innerOrContent","WriteFloatProperty","IncrementChildCount","childCount","PropertyName","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","currEl","Flow","story","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","WriteListRuntimeObjs","hasChoiceThreads","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","ToJson","indented","LoadJson","json","TextToDictionary","LoadJsonObj","onDidLoadState","VisitCountAtPathString","pathString","visitCountOut","_patch","VisitCountForContainer","containerPathStr","count2","IncrementVisitCountForContainer","currCount","RecordTurnIndexVisitToContainer","currentTurnIndex","TurnsSinceForContainer","index2","callstackDepth","_currentFlow","canContinue","generatedChoices","currentErrors","_currentErrors","currentWarnings","_currentWarnings","variablesState","_variablesState","evaluationStack","_evaluationStack","_currentTurnIndex","currentPathString","previousPathString","hasError","hasWarning","currentText","_outputStreamTextDirty","inTag","outputObj","textContent","controlCommand","_currentText","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","currentTags","_outputStreamTagsDirty","_currentTags","txt","currentFlowName","currentFlowIsDefaultFlow","kDefaultFlowName","aliveFlowNames","_aliveFlowNamesDirty","_aliveFlowNames","_namedFlows","flowName","keys","kInkSaveStateVersion","kMinCompatibleLoadVersion","divertedPointer","storySeed","previousRandom","didSafeExit","OutputStreamDirty","timeSeed","Date","getTime","GoToStart","mainContentContainer","SwitchFlow_Internal","flow","SwitchToDefaultFlow_Internal","RemoveFlow_Internal","CopyAndStartPatching","forBackgroundSave","namedFlowKey","namedFlowValue","RestoreAfterPatch","ApplyAnyPatch","ApplyCountChanges","newCount","isVisit","WriteIntDictionary","inkVersionCurrent","jSaveVersion","flowsObj","flowsObjDict","flowsObjDictEntries","entries","namedFlowObjKey","namedFlowObjValue","flowObj","currFlowName","currentDivertTargetPath","divertPath","JObjectToIntDictionary","ResetErrors","ResetOutput","objs","PushToOutputStream","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","PopFromOutputStream","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","trimIndex","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","inStringEvaluation","PushEvaluationStack","n","PopEvaluationStack","numberOfObjects","PeekEvaluationStack","ForceEnd","TrimWhitespaceFromFunctionEnd","functionStartPoint","PopCallStack","popType","SetChosenPath","incrementingTurnIndex","newPointer","StartFunctionEvaluationFromGame","funcContainer","PassArgumentsToEvaluationStack","TryExitFunctionEvaluationFromGame","CompleteFunctionEvaluationFromGame","originalEvaluationStackHeight","returnedObj","poppedObj","returnVal","AddError","isWarning","Stopwatch","startTime","ElapsedMilliseconds","Start","Stop","nVal","isFinite","choices","_state","IfAsyncWeCant","_listDefinitions","StartProfiling","EndProfiling","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","jsonString","_externals","rootObject","versionObj","formatFromFile","listDefsObj","rootToken","JTokenToListDefinitions","ResetState","shouldReturn","VariableStateDidChangeEvent","bind","ResetGlobals","ResetCallstack","originalPointer","ChoosePath","ContinueInternal","SwitchFlow","RemoveFlow","SwitchToDefaultFlow","Continue","ContinueAsync","asyncContinueComplete","millisecsLimitAsync","ValidateExternalBindings","PreContinue","isAsyncTimeLimited","durationStopwatch","ContinueSingleStep","changedVariablesToObserve","RestoreStateSnapshot","PostContinue","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","ContinueMaximally","KnotContainerWithName","pathLengthToUse","CopyStateForBackgroundThreadSave","stateToSave","BackgroundSaveComplete","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","NextContent","atStart","VisitChangedContainersDueToDivert","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","PopChoiceStringAndTags","choiceOnlyStrVal","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","reverse","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","evalCommand","output","overrideTunnelReturnTarget","popped","names","expected","errorMsg","contentStackForTag","outputCountConsumed","command","choiceTag","contentStackForString","contentToRetain","rescuedTag","choiceCount","extraNote","eitherCount","divertTarget","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","listNameVal","generatedListValue","foundItem","targetList","listItemIndex","listEnumerator","randomItem","assignedVal","foundValue","func","funcParams","ChoosePathString","resetCallstack","funcDetail","activityStr","ChooseChoiceIndex","choiceIdx","choiceToChoose","HasFunction","EvaluateFunction","returnTextOutput","trim","outputStreamBefore","stringOutput","textOutput","returned","EvaluateExpression","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","valueObj","funcResult","function","returnObj","BindExternalFunctionGeneral","lookaheadSafe","TryCoerce","BindExternalFunction","coercedArgs","apply","UnbindExternalFunction","missingExternals","from","innerContent","ObserveVariable","observer","ObserveVariables","variableNames","observers","RemoveVariableObserver","specificVariableName","variableObservers","newValueObj","globalTags","TagsAtStartOfFlowContainerWithPathString","TagsForContentAtPath","flowContainer","firstContent","BuildStringOfContainer","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","endLineNumber","fileName"],"mappings":"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"}